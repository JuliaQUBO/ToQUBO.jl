# -*- Pseudo-boolean Functions-*-
include("./pbo.jl")
using .PBO

# -*- Alias -*-
const ‚Ñ±{T} = PBF{VI, T}

# -*- Virtual Variables -*-
include("./varmap.jl")
using .VarMap

# -*- Alias -*-
# Bind VirtualVar{S, T}, S to OI.VariableIndex
const ùí±{T} = VV{VI, T}

# -*- QUBO Model -*-
mutable struct QUBOModel{T <: Any} <: MOIU.AbstractModelLike{T}
    # -*- MOI Model-Like -*-
    model::MOIU.Model{T}

    # -*- Virtual Variable Interface -*-
    varvec::Vector{ùí±{T}}

    source::Dict{VI, ùí±{T}}
    target::Dict{VI, ùí±{T}}

    # - For PBF Reduction
    cache::Dict{Set{VI}, ‚Ñ±{T}}

    # - Slack Variable Count
    slack::Int
    
    # - Underlying Optimizer
    sampler::Union{Nothing, AbstractSampler{T}}

    # Hamiltonian
    ‚Ñç‚ÇÄ::‚Ñ±{T} # Objective
    ‚Ñç·µ¢::‚Ñ±{T} # Constraints

    # -*- MOI Stuff -*-
    # - ObjectiveValue (Avaliar somente ‚Ñç‚ÇÄ(s) ou tamb√©m E(s)?)
    objective_value::Float64
    # - SolveTimeSec
    solve_time_sec::Float64
    # - TerminationStatus (n√£o est√° 100% claro na minha cabe√ßa o que deve retornado aqui)
    termination_status::Any
    # - PrimalStatus (idem)
    primal_status::Any
    # - RawStatusString
    raw_status_str::Union{Nothing, String}

    function QUBOModel{T}(sampler::Union{Nothing, AbstractSampler{T}}=nothing) where T
        return new{T}(
            MOIU.Model{T}(),
            Vector{ùí±{T}}(),
            Dict{VI, ùí±{T}}(),
            Dict{VI, ùí±{T}}(),
            Dict{Set{VI}, ‚Ñ±{T}}(),
            0,
            sampler,
            ‚Ñ±{T}(),
            ‚Ñ±{T}(),
            NaN,
            NaN,
            nothing,
            nothing,
            nothing,
        )
    end
end

# -*- Default -*-
function QUBOModel(sampler::AbstractSampler{VI, Bool, Float64})
    return QUBOModel{Float64}(sampler)
end

function QUBOModel()
    return QUBOModel{Float64}()
end

# ::: Variable Management :::

# -*- Add Generic Variable -*-
"""
General Interface for variable inclusion on QUBO Models.


"""
function addvar(model::QUBOModel{T}, source::Union{VI, Nothing}, bits::Int; name::Symbol=:x, domain::Tuple{T, T}=(zero(T), one(T)))::ùí±{T} where T
    # -*- Add MOI Variables to underlying model -*-
    target = MOI.add_variables(model.model, bits)::Vector{VI}

    if source === nothing
        # -*- Slack Variable -*-
        model.slack += 1
        name = Symbol(subscript(model.slack, var=name, par=true))
    else
        name = :x
    end

    # -*- Virtual Variable -*-
    Œ±, Œ≤ = domain

    v = ùí±{T}(bits, target, source; name=name, Œ±=Œ±, Œ≤=Œ≤)

    for v·µ¢ in target
        # -*- Make Variable Binary -*-
        MOI.add_constraint(model.model, v·µ¢, ZO())
        MOI.set(model.model, MOI.VariableName(), v·µ¢, subscript(v·µ¢, var=name))
        model.target[v·µ¢] = v
    end

    push!(model.varvec, v)

    return v
end


# -*- Add Slack Variable -*-
function addslack(model::QUBOModel{T}, bits::Int; name::Symbol=:s, domain::Tuple{T, T}=(zero(T), one(T)))::ùí±{T} where T
    return addvar(model, nothing, bits, name=name, domain=domain)
end

# -*- Expand: Interpret existing variable through its binary expansion -*-
function expand!(model::QUBOModel{T}, src::VI, bits::Int; name::Symbol=:x, domain::Tuple{T, T}=(zero(T), one(T)))::ùí±{T} where T
    model.source[src] = addvar(model, src, bits; name=name, domain=domain)
end

function expand(model::QUBOModel{T}, src::VI, bits::Int; name::Symbol=:x, domain::Tuple{T, T}=(zero(T), one(T)))::ùí±{T} where T
    expand!(model, src, bits, name=name, domain=domain)
    return model.source[src]
end

# -*- Mirror: Make existing variable Binary -*-
function mirror!(model::QUBOModel{T}, var::VI; name::Symbol=:x)::ùí±{T} where T
    expand!(model, var, 1, name=name)
end

function mirror(model::QUBOModel{T}, var::VI; name::Symbol=:x)::ùí±{T} where T
    mirror!(model, var, name=name)
    return model.source[var]
end

function vars(model::QUBOModel{T})::Vector{ùí±{T}} where T
    return Vector{ùí±{T}}(model.varvec)
end

function slackvars(model::QUBOModel{T})::Vector{ùí±{T}} where T
    return Vector{ùí±{T}}([v for v in model.varvec if isslack(v)])
end

# -*- QUBO Validation -*-
raw"""
    isqubo(model::MOI.ModelLike)::Bool

Tells if `model` is ready as QUBO Model. A few conditions must be met:
    1. All variables must be binary (VariableIndex-in-ZeroOne)
    2. No other constraints are allowed
    3. The objective function must be either ScalarQuadratic, ScalarAffine or VariableIndex
"""
function isqubo(T::Type{<: Any}, model::MOI.ModelLike)
    F = MOI.get(model, MOI.ObjectiveFunctionType()) 
    
    if !(F === SQF{T} || F === SAF{T} || F === VI)
        return false
    end

    # List of Variables
    v = Set{VI}(MOI.get(model, MOI.ListOfVariableIndices()))

    for (F, S) in MOI.get(model, MOI.ListOfConstraints())
        if !(F === VI && S === ZO)
            # Non VariableIndex-in-ZeroOne Constraint
            return false
        else
            for c·µ¢ in MOI.get(model, MOI.ListOfConstraintIndices{F, S}())
                v·µ¢ = MOI.get(model, MOI.ConstraintFunction(), c·µ¢)
                
                # Account for variable as binary
                delete!(v, v·µ¢)
            end

            if !isempty(v)
                # Some variable is not covered by binary constraints
                return false
            end
        end
    end

    return true
end

function isqubo(model::QUBOModel{T}) where {T}
    return isqubo(T, model.model)
end

# ::: QUBO Conversion :::

# -*- Variables -*-
function toqubo_variables!(‚Ñ≥::MOI.ModelLike, ùí¨::QUBOModel{T}) where {T}
    # ::: Variable Analysis :::

    # Set of all source variables
    Œ© = Set{VI}(MOI.get(‚Ñ≥, MOI.ListOfVariableIndices()))

    ùïã = Union{Missing, T}

    # Variable Sets and Bounds (Boolean, Integer, Real)
    ùîπ = Set{VI}()
    ‚Ñ§ = Dict{VI, Tuple{ùïã, ùïã}}()
    ‚Ñù = Dict{VI, Tuple{ùïã, ùïã}}()

    for c·µ¢ in MOI.get(‚Ñ≥, MOI.ListOfConstraintIndices{VI, MOI.ZeroOne()}())
        # -*- Binary Variable üòÑ -*-
        x·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintFunction(), c·µ¢)

        # Add to set
        push!(ùîπ, x·µ¢)
    end

    for c·µ¢ in MOI.get(‚Ñ≥, MOI.ListOfConstraintIndices{VI, MOI.Integer()}())
        # -*- Integer Variable ü§î -*-
        x·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintFunction(), c·µ¢)

        # Add to dict as unbounded
        ‚Ñ§[x·µ¢] = (missing, missing)
    end

    for x·µ¢ in setdiff(Œ©, ùîπ, ‚Ñ§)
        # -*- Real Variable üò¢ -*-
        ‚Ñù[x·µ¢] = (missing, missing)
    end

    for c·µ¢ in MOI.get(‚Ñ≥, MOI.ListOfConstraintIndices{VI, MOI.Interval()}())
        # -*- Interval üòÑ -*-
        x·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintFunction(), c·µ¢)
        I·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintSet(), c·µ¢) 

        a·µ¢ = I·µ¢.lower
        b·µ¢ = I·µ¢.upper

        if haskey(‚Ñ§, x·µ¢)
            ‚Ñ§[x·µ¢] = (a·µ¢, b·µ¢)
        elseif haskey(‚Ñù, x·µ¢)
            ‚Ñù[x·µ¢] = (a·µ¢, b·µ¢)
        end
    end

    for c·µ¢ in MOI.get(‚Ñ≥, MOI.ListOfConstraintIndices{VI, MOI.LessThan()}())
        # -*- Upper Bound ü§î -*-
        x·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintFunction(), c·µ¢)
        I·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintSet(), c·µ¢) 

        b·µ¢ = I·µ¢.upper

        if haskey(‚Ñ§, x·µ¢)
            ‚Ñ§[x·µ¢] = (‚Ñ§[x·µ¢][0], b·µ¢)
        elseif haskey(‚Ñù, x·µ¢)
            ‚Ñù[x·µ¢] = (‚Ñù[x·µ¢][0], b·µ¢)
        end
    end

    for c·µ¢ in MOI.get(‚Ñ≥, MOI.ListOfConstraintIndices{VI, MOI.GreaterThan()}())
        # -*- Lower Bound ü§î -*-
        x·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintFunction(), c·µ¢)
        I·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintSet(), c·µ¢)

        a·µ¢ = I·µ¢.lower

        if haskey(‚Ñ§, x·µ¢)
            ‚Ñ§[x·µ¢] = (a·µ¢, ‚Ñ§[x·µ¢][1])
        elseif haskey(‚Ñù, x·µ¢)
            ‚Ñù[x·µ¢] = (a·µ¢, ‚Ñ§[x·µ¢][1])
        end
    end

    # STRONG TODO: bits magic
    bits = 3 # WHY ????!!!!!!

    # -*- Discretize Real Ones ü§î -*-
    for (x·µ¢, (a·µ¢, b·µ¢)) in ‚Ñù
        if a·µ¢ === missing || b·µ¢ === missing
            error("Unbounded variable $x·µ¢ ‚àà ‚Ñ§")
        else
            expand!(ùí¨, x·µ¢, bits; domain=(a·µ¢, b·µ¢))
        end
    end

    # -*- Discretize Integer Variables ü§î -*-
    for (x·µ¢, (a·µ¢, b·µ¢)) in ‚Ñ§
        if a·µ¢ === missing || b·µ¢ === missing
            error("Unbounded variable $x·µ¢ ‚àà ‚Ñ§")
        else
            expand!(ùí¨, x·µ¢, bits; domain=(a·µ¢, b·µ¢))
        end
    end

    # -*- Mirror Boolean Variables üòÑ -*-
    for x·µ¢ in ùîπ
        mirror!(ùí¨, x·µ¢)
    end
end

# -*- Objective Function -*-
function toqubo_objective!(‚Ñ≥::MOI.ModelLike, ùí¨::QUBOModel{T}, ::VI) where {T}
    # -*- Single Variable -*-
    x·µ¢ = MOI.get(‚Ñ≥, MOI.ObjectiveFunction{VI}())
    v·µ¢ = ùí¨.source[x·µ¢]

    for (x·µ¢‚±º, c·µ¢‚±º) in v·µ¢
        ùí¨.‚Ñç‚ÇÄ[x·µ¢‚±º] += c·µ¢‚±º
    end
end

function toqubo_objective!(‚Ñ≥::MOI.ModelLike, ùí¨::QUBOModel{T}, ::SAF{T}) where {T}
    # -*- Affine Terms -*-
    f = MOI.get(‚Ñ≥, MOI.ObjectiveFunction{SAF{T}}())

    for a·µ¢ in f.terms
        c·µ¢ = a·µ¢.coefficient
        x·µ¢ = a·µ¢.variable

        v·µ¢ = ùí¨.source[x·µ¢]

        for (x·µ¢‚±º, d·µ¢‚±º) in v·µ¢
            ùí¨.‚Ñç‚ÇÄ[x·µ¢‚±º] += c·µ¢ * d·µ¢‚±º
        end
    end

    # -*- Constant -*-
    ùí¨.‚Ñç‚ÇÄ += f.constant
end

function toqubo_objective!(‚Ñ≥::MOI.ModelLike, ùí¨::QUBOModel{T}, F::Type{<: SAF{T}}) where {T}
    # -*- Affine Terms -*-
    f = MOI.get(‚Ñ≥, MOI.ObjectiveFunction{F}())

    # Quadratic Terms
    for Q·µ¢ in f.quadratic_terms
        c·µ¢ = Q·µ¢.coefficient
        x·µ¢ = Q·µ¢.variable_1
        y·µ¢ = Q·µ¢.variable_2

        v·µ¢ = ùí¨.source[x·µ¢]
        w·µ¢ = ùí¨.source[y·µ¢]

        for (x·µ¢‚±º, d·µ¢‚±º) in v·µ¢
            for (y·µ¢‚Çñ, d·µ¢‚Çñ) in w·µ¢
                z‚±º‚Çñ = Set{VI}([x·µ¢‚±º, y·µ¢‚Çñ])
                ùí¨.‚Ñç‚ÇÄ[z‚±º‚Çñ] += c·µ¢ * d·µ¢‚±º * d·µ¢‚Çñ
            end
        end
    end

    for a·µ¢ in f.affine_terms
        c·µ¢ = a·µ¢.coefficient
        x·µ¢ = a·µ¢.variable

        v·µ¢ = ùí¨.source[x·µ¢]

        for (x·µ¢‚±º, d·µ¢‚±º) in v·µ¢
            ùí¨.‚Ñç‚ÇÄ[x·µ¢‚±º] += c·µ¢ * d·µ¢‚±º
        end
    end

    # -*- Constant -*-
    ùí¨.‚Ñç‚ÇÄ += f.constant
end

# -*- Constraints -*-
function toqubo_constraint!(‚Ñ≥::MOI.ModelLike, ùí¨::QUBOModel{T}, F::SAF{T}, S::EQ{T}) where {T}
    # -*- Scalar Affine Function: Ax = b üòÑ -*-
    for c·µ¢ in MOI.get(‚Ñ≥, MOI.ListOfConstraintIndices{F, S}())
        r·µ¢ = ‚Ñ±{T}()

        A·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintFunction(), c·µ¢)
        b·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintSet(), c·µ¢).value

        for a‚±º in A·µ¢.terms
            c‚±º = a‚±º.coefficient
            x‚±º = a‚±º.variable

            v‚±º = ùí¨.source[x‚±º]

            for (y‚±º‚Çñ, d‚±º‚Çñ) in v‚±º
                r·µ¢[y‚±º‚Çñ] += c‚±º * d‚±º‚Çñ
            end 
        end

        q·µ¢ = reduce_degree(
            (r·µ¢ - b·µ¢) ^ 2;
            cache=ùí¨.cache,
            slack=()->addslack(ùí¨, 1, name=:w)
        )

        ùí¨.‚Ñç·µ¢ += q·µ¢
    end
end

function toqubo_constraint!(‚Ñ≥::MOI.ModelLike, ùí¨::QUBOModel{T}, F::SAF{T}, S::LT{T}) where {T}
    # -*- Scalar Affine Function: Ax <= b ü§î -*-

    for c·µ¢ in MOI.get(‚Ñ≥, MOI.ListOfConstraintIndices{F, S}())
        r·µ¢ = Posiform{VI, T}()

        A·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintFunction(), c·µ¢)
        b·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintSet(), c·µ¢).upper

        for a‚±º in A·µ¢.terms
            c‚±º = a‚±º.coefficient
            x‚±º = a‚±º.variable

            v‚±º = ùí¨.source[x‚±º]

            for (y‚±º‚Çñ, d‚±º‚Çñ) in v‚±º
                r·µ¢[y‚±º‚Çñ] += c‚±º * d‚±º‚Çñ
            end 
        end

        # -*- Introduce Slack Variable -*-
        s·µ¢ = ‚Ñ±{T}()

        # TODO: Heavy Inference going on!
        bits = ceil(Int, log(2, b·µ¢))

        Œ± = zero(T)
        Œ≤ = b·µ¢

        for (s·µ¢‚±º, d·µ¢‚±º) in addslack(ùí¨, bits, domain=(Œ±, Œ≤), name=:s)
            s·µ¢[s·µ¢‚±º] += d·µ¢‚±º
        end

        q·µ¢ = reduce_degree(
            (r·µ¢ + s·µ¢ - b·µ¢) ^ 2;
            cache=ùí¨.cache,
            slack=()->addslack(ùí¨, 1, name=:w)
        )

        ùí¨.‚Ñç·µ¢ += q·µ¢
    end
end

function toqubo_constraint!(‚Ñ≥::MOI.ModelLike, ùí¨::QUBOModel{T}, F::SAF{T}, S::GT{T}) where {T}
    # -*- Scalar Affine Function: Ax >= b ü§î -*-
    for c·µ¢ in MOI.get(‚Ñ≥, MOI.ListOfConstraintIndices{F, S}())
        r·µ¢ = Posiform{VI, T}()

        A·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintFunction(), c·µ¢)
        b·µ¢ = MOI.get(‚Ñ≥, MOI.ConstraintSet(), c·µ¢).lower

        for a‚±º in A·µ¢.terms
            c‚±º = a‚±º.coefficient
            x‚±º = a‚±º.variable

            v‚±º = ùí¨.source[x‚±º]

            for (y‚±º‚Çñ, d‚±º‚Çñ) in v‚±º
                r·µ¢[y‚±º‚Çñ] += c‚±º * d‚±º‚Çñ
            end 
        end

        # -*- Introduce Slack Variable -*-
        s·µ¢ = ‚Ñ±{T}()

        # TODO: Heavy Inference going on!
        bits = ceil(Int, log(2, b·µ¢))

        Œ± = zero(T)
        Œ≤ = b·µ¢

        for (s·µ¢‚±º, d·µ¢‚±º) in addslack(ùí¨, bits, domain=(Œ±, Œ≤), name=:s)
            s·µ¢[s·µ¢‚±º] += d·µ¢‚±º
        end

        q·µ¢ = reduce_degree(
            (r·µ¢ - s·µ¢ - b·µ¢) ^ 2;
            slack=()->addslack(ùí¨, 1, name=:w),
            cache=ùí¨.cache
        )

        ùí¨.‚Ñç·µ¢ += q·µ¢
    end
end

# -*- From ModelLike to QUBO -*-
function toqubo(T::Type{<: Any}, ‚Ñ≥::MOI.ModelLike; sampler::Union{Nothing, AbstractSampler}=nothing)
    # -*- Support Validation -*-
    supported_objective(‚Ñ≥)
    supported_constraints(‚Ñ≥)

    # -*- Create QUBO Model -*-
    # This allows one to use MOI.copy_to afterwards
    ùí¨ = QUBOModel{T}(sampler)

    toqubo_variables!(‚Ñ≥, ùí¨)

    # ::: Objective Analysis :::
    F = MOI.get(‚Ñ≥, MOI.ObjectiveFunctionType())

    # -*- Objective Function Posiform -*-
    toqubo_objective!(‚Ñ≥, ùí¨, F)

    # ::: Constraint Analysis :::

    for (F, S) in MOI.get(‚Ñ≥, MOI.ListOfConstraints())
        toqubo_constraint!(‚Ñ≥, ùí¨, F, S)
    end

    # -*- Objective Function Assembly -*-
    MOI.set(
        ùí¨.model,
        MOI.ObjectiveSense(),
        MOI.get(‚Ñ≥, MOI.ObjectiveSense())
    )

    Q = []
    a = []
    b = zero(T)

    ‚Ñç = (ùí¨.‚Ñç‚ÇÄ + ùí¨.‚Ñç·µ¢) # Total Energy

    for (œâ, c) in ‚Ñç
        n = length(œâ)

        if n == 0
            b += c
        elseif n == 1
            push!(a, SAT{T}(c, œâ...))
        elseif n == 2
            push!(Q, SQT{T}(c, œâ...))
        else
            error("Degree reduction failed!")
        end
    end

    MOI.set(
        ùí¨.model,
        MOI.ObjectiveFunction{SQF{T}}(),
        SQF{T}(Q, a, b)
    )

    return ùí¨   
end