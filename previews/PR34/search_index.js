var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Knapsack","page":"Examples","title":"Knapsack","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We start with some instances of the discrete Knapsack Problem whose standard formulation is","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginarrayr l\n    max         mathbfc mathbfx \n    textst  mathbfw mathbfx le C \n                mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"examples/#MathOptInterface","page":"Examples","title":"MathOptInterface","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Using MOI directly to build a simple model is pretty straightforward. All that one has to do is to use MOI.instantiate and define the model as usual.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import MathOptInterface as MOI\nconst MOIU = MOI.Utilities\n\nusing ToQUBO\nusing Anneal # <- Your favourite Annealer / Sampler / Solver here\n\n# Example from https://jump.dev/MathOptInterface.jl/stable/tutorials/example/\n\n# Virtual QUBO Model\nmodel = MOI.instantiate(\n   () -> ToQUBO.Optimizer(SimulatedAnnealer.Optimizer),\n   with_bridge_type = Float64,\n)\n\nn = 3;\nc = [1.0, 2.0, 3.0]\nw = [0.3, 0.5, 1.0]\nC = 3.2;\n\n# -*- Variables -*- #\nx = MOI.add_variables(model, n);\n\n# -*- Objective -*- #\nMOI.set(model, MOI.ObjectiveSense(), MOI.MAX_SENSE)\n\nMOI.set(\n   model,\n   MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),\n   MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0),\n);\n\n# -*- Constraints -*- #\nMOI.add_constraint(\n   model,\n   MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),\n   MOI.LessThan(C),\n);\n\nfor xᵢ in x\n   MOI.add_constraint(model, xᵢ, MOI.ZeroOne())\nend\n\n# Run!\nMOI.optimize!(model)\n\n# Collect Solution\nMOI.get(model, MOI.VariablePrimal(), x)","category":"page"},{"location":"examples/#JuMP-D-Wave-Examples","page":"Examples","title":"JuMP + D-Wave Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We may now fill a few more knapsacks using JuMP. We will generate uniform random costs mathbfc and weights mathbfw then set the knapsack's capacity C to be a fraction of the total available weight i.e. 80.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example was inspired by D-Wave's knapsack example repository.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CSV\nusing DataFrames\nusing Random\n\n# -> Generate Data <-\nrng = MersenneTwister(1)\n\ndf = DataFrame(\n   :cost   => rand(rng, 1:100, 16),\n   :weight => rand(rng, 1:100, 16),\n)\n\nCSV.write(\"knapsack.csv\", df)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using CSV\nusing DataFrames\n\ndf = CSV.read(\"knapsack.csv\", DataFrame)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using JuMP\nusing ToQUBO\nusing Anneal # <- Your favourite Annealer / Sampler / Solver here\n\n# -> Model <-\nmodel = Model(() -> ToQUBO.Optimizer(SimulatedAnnealer.Optimizer))\n\nn = size(df, 1)\nc = collect(Float64, df[!, :cost])\nw = collect(Float64, df[!, :weight])\nC = round(0.8 * sum(w))\n\n# -> Variables <-\n@variable(model, x[i=1:n], Bin)\n\n# -> Objective <-\n@objective(model, Max, c' * x)\n\n# -> Constraint <-\n@constraint(model, w' * x <= C)\n\n# ->-> Run! ->->\noptimize!(model)\n\n# Add Results as a new column\ninsertcols!(\n   df,\n   3, \n   :select => map(\n      (ξ) -> (ξ > 0.0) ? \"Yes\" : \"No\",\n      value.(x),\n   ),\n)","category":"page"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Quick-Start-Guide","page":"Manual","title":"Quick Start Guide","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"using JuMP\nusing ToQUBO\nusing Anneal\n\nmodel = Model(() -> ToQUBO.Optimizer(SimulatedAnnealer.Optimizer))\n\n@variable(model, x[1:3], Bin)\n@objective(model, Max, 1.0 * x[1] + 2.0 * x[2] + 3.0 * x[3])\n@constraint(model, 0.3 * x[1] + 0.5 * x[2] + 1.0 * x[3] <= 3.2)\n\noptimize!(model)\n\nsolution_summary(model)","category":"page"},{"location":"#ToQUBO.jl-Documentation","page":"Home","title":"ToQUBO.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ToQUBO.jl is a Julia Package intended to automatically translate models written in JuMP, into the QUBO mathematical optimization framework.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#**Pre-release-note:**","page":"Home","title":"Pre-release note:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is not yet available through Julia's package manager. Thus, it is still necessary to clone ToQUBO.jl from its GitHub repo.","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ git clone https://github.com/psrenergy/ToQUBO.jl\n$ cd ToQUBO.jl\n$ julia --project=.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the Anneal.jl submodule, it will be necessary to run","category":"page"},{"location":"","page":"Home","title":"Home","text":"(ToQUBO) pkg> dev .\\\\src\\\\Anneal.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"on Julia's REPL beforehand.","category":"page"},{"location":"#Citing-ToQUBO.jl","page":"Home","title":"Citing ToQUBO.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ToQUBO.jl in your work, we kindly ask you to include the following citation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{ToQUBO.jl:2022,\n  author = {Pedro Xavier and Tiago Andrade and Joaquim Garcia and David Bernal},\n  title = {ToQUBO.jl},\n  url = {https://github.com/psrenergy/ToQUBO.jl},\n  version = {0.1.0},\n  date = {2022-03-31},\n}","category":"page"},{"location":"booklet/#ToQUBO.jl-Booklet","page":"Booklet","title":"ToQUBO.jl Booklet","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"This booklet aims to gather the theoretical and practical details behind ToQUBO and provide documentation for project internals. The target audience includes, among others, advanced users and those willing to contribute to the project. The latter are advised to read the following sections, as they give a glimpse of the ideas employed up to now.","category":"page"},{"location":"booklet/#QUBO","page":"Booklet","title":"QUBO","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"beginarrayrl\n   min         mathbfx^intercal Qmathbfx \n   textst  mathbfx in mathbbB^n\nendarray","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.isqubo\nToQUBO.toqubo\nToQUBO.toqubo!","category":"page"},{"location":"booklet/#ToQUBO.isqubo","page":"Booklet","title":"ToQUBO.isqubo","text":"isqubo(model::MOI.ModelLike)\n\nTells if a given model is ready to be interpreted as a QUBO model.\n\nFor it to be true, a few conditions must be met:\n\nAll variables must be binary (MOI.VariableIndex ∈ MOI.ZeroOne)\nNo other constraints are allowed\nThe objective function must be of type MOI.ScalarQuadraticFunction, MOI.ScalarAffineFunction or MOI.VariableIndex\nThe objective sense must be either MOI.MIN_SENSE or MOI.MAX_SENSE\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo","page":"Booklet","title":"ToQUBO.toqubo","text":"toqubo(T::Type, source::MOI.ModelLike, optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing)\ntoqubo(source::MOI.ModelLike, optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing)\n\nLow-level interface to create a ::VirtualQUBOModel{T} from ::MOI.ModelLike instance. If provided, an ::MOI.AbstractOptimizer is attached to the model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo!","page":"Booklet","title":"ToQUBO.toqubo!","text":"toqubo!(model::VirtualQUBOModel{T}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.toqubo_sense!\nToQUBO.toqubo_variables!\nToQUBO.toqubo_constraint!\nToQUBO.toqubo_objective!","category":"page"},{"location":"booklet/#ToQUBO.toqubo_sense!","page":"Booklet","title":"ToQUBO.toqubo_sense!","text":"toqubo_sense!(model::VirtualQUBOModel)\n\nCopies MOI.ObjectiveSense from model.source_model to model.target_model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_variables!","page":"Booklet","title":"ToQUBO.toqubo_variables!","text":"toqubo_variables!(model::VirtualQUBOModel{T}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_constraint!","page":"Booklet","title":"ToQUBO.toqubo_constraint!","text":"toqubo_constraint!(model::VirtualQUBOModel{T}, F::Type{<:SAF{T}}, S::Type{<:EQ{T}}) where {T}\ntoqubo_constraint!(model::VirtualQUBOModel{T}, F::Type{<:SAF{T}}, S::Type{<:LT{T}}) where {T}\ntoqubo_constraint!(model::VirtualQUBOModel{T}, F::Type{<:SQF{T}}, S::Type{<:EQ{T}}) where {T}\ntoqubo_constraint!(model::VirtualQUBOModel{T}, F::Type{<:SQF{T}}, S::Type{<:LT{T}}) where {T}\ntoqubo_constraint!(::VirtualQUBOModel{T}, ::Type{<:VI}, ::Type{<:Union{MOI.ZeroOne, MOI.Integer, MOI.Interval{T}, MOI.LessThan{T}, MOI.GreaterThan{T}}}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.toqubo_objective!","page":"Booklet","title":"ToQUBO.toqubo_objective!","text":"toqubo_objective!(model::VirtualQUBOModel{T}, F::Type{<:VI}) where {T}\ntoqubo_objective!(model::VirtualQUBOModel{T}, F::Type{<:SAF{T}}) where {T}\ntoqubo_objective!(model::VirtualQUBOModel{T}, F::Type{<:SQF{T}}) where {T}\n\n\n\n\n\n","category":"function"},{"location":"booklet/#Pseudo-Boolean-Optimization","page":"Booklet","title":"Pseudo-Boolean Optimization","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Internally, problems are represented through a Pseudo-Boolean Optimization (PBO) framework. The main goal is to represent a given problem using a Pseudo-Boolean Function (PBF) since there is an immediate correspondence between quadratic PBFs and QUBO forms.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.PBO.PseudoBooleanFunction\nToQUBO.PBO.residual\nToQUBO.PBO.derivative\nToQUBO.PBO.gradient\nToQUBO.PBO.gap\nToQUBO.PBO.sharpness\nToQUBO.PBO.discretize\nToQUBO.PBO.relaxed_gcd","category":"page"},{"location":"booklet/#ToQUBO.PBO.PseudoBooleanFunction","page":"Booklet","title":"ToQUBO.PBO.PseudoBooleanFunction","text":"PseudoBooleanFunction{S, T}(c::T)\nPseudoBooleanFunction{S, T}(ps::Pair{Vector{S}, T}...)\n\nA Pseudo-Boolean Function f in mathscrF over some field mathbbT takes the form\n\nf(mathbfx) = sum_omega in Omegaleftfright c_omega prod_j in omega mathbbx_j\n\nwhere each Omegaleftfright is the multi-linear representation of f as a set of terms. Each term is given by a unique set of indices omega subseteq mathbbS related to some coefficient c_omega in mathbbT. We say that omega in Omegaleftfright iff c_omega neq 0. Variables mathbfx_i are indeed boolean, thus f  mathbbB^n to mathbbT.\n\nReferences\n\n[1] Endre Boros, Peter L. Hammer, Pseudo-Boolean optimization, Discrete Applied Mathematics, 2002 {doi}\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.PBO.residual","page":"Booklet","title":"ToQUBO.PBO.residual","text":"residual(f::PBF{S, T}, i::S) where {S, T}\nresidual(f::PBF{S, T}, i::Int) where {S, T}\n\nThe residual of function f in mathscrF with respect to the i-th variable.\n\n    Theta_i f(mathbfx) = f(mathbfx) - mathbfx_i Delta_i f(mathbfx) =\n    sum_omega in Omegaleftfright setminus leftiright\n    c_omega prod_k in omega mathbfx_k\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.PBO.derivative","page":"Booklet","title":"ToQUBO.PBO.derivative","text":"derivative(f::PBF{S, T}, i::S) where {S, T}\nderivative(f::PBF{S, T}, i::Int) where {S, T}\n\nThe partial derivate of function f in mathscrF with respect to the i-th variable.\n\n    Delta_i f(mathbfx) = fracpartial f(mathbfx)partial mathbfx_i =\n    sum_omega in Omegaleftfright setminus leftiright\n    c_omega cup leftiright prod_k in omega mathbfx_k\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.PBO.gradient","page":"Booklet","title":"ToQUBO.PBO.gradient","text":"gradient(f::PBF)\n\nComputes the gradient of f in mathscrF where the i-th derivative is given by derivative.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.PBO.gap","page":"Booklet","title":"ToQUBO.PBO.gap","text":"gap(f::PBF{S, T}; bound::Symbol=:loose) where {S, T}\n\nComputes the least upper bound for the greatest variantion possible under some f in mathscrF i. e.\n\nbeginarrayr l\n    min         M \n    textst  leftf(mathbfx) - f(mathbfy)right le M  forall mathbfx mathbfy in mathbbB^n \nendarray\n\nA simple approach, avaiable using the bound=:loose parameter, is to define\n\nM triangleq sum_omega neq varnothing leftc_omegaright\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.PBO.sharpness","page":"Booklet","title":"ToQUBO.PBO.sharpness","text":"sharpness(f::PBF{S, T}; bound::Symbol=:loose, tol::T = T(1e-6)) where {S, T<:AbstractFloat}\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.PBO.discretize","page":"Booklet","title":"ToQUBO.PBO.discretize","text":"discretize(f::PBF{S, T}; tol::T) where {S, T}\n\nFor a given function f in mathscrF written as\n\n    fleft(mathbfxright) = sum_omega in Omegaleftfright c_omega prod_i in omega mathbfx_i\n\ncomputes an approximate function  g  mathbbB^n to mathbbZ such that\n\n    argmin_mathbfx in mathbbB^n gleft(mathbfxright) = argmin_mathbfx in mathbbB^n fleft(mathbfxright)\n\nThis is done by rationalizing every coefficient c_omega according to some tolerance tol.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.PBO.relaxed_gcd","page":"Booklet","title":"ToQUBO.PBO.relaxed_gcd","text":"relaxed_gcd(x::T, y::T; tol::T = T(1e-6)) where {T <: AbstractFloat}\n\nWe define two real numbers x and y to be tau-comensurable if, for some tau  0 there exists a continued fractions convergent p_k div q_k such that\n\n    left q_k x - p_k y right le tau\n\n\n\n\n\n","category":"function"},{"location":"booklet/#Quadratization","page":"Booklet","title":"Quadratization","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"In order to successfully achieve a QUBO formulation, sometimes it is needed to quadratize the resulting PBF, i.e., reduce its degree until reaching the quadratic case. There are many quadratization methods available, and ToQUBO implements a few of them.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.PBO.quadratize\nToQUBO.PBO.@quadratization","category":"page"},{"location":"booklet/#ToQUBO.PBO.quadratize","page":"Booklet","title":"ToQUBO.PBO.quadratize","text":"quadratize(f::PBF{S, T}; slack::Any) where {S, T}\n\nQuadratizes a given PBF, i.e. creates a function g in mathscrF^2 from f in mathscrF^k k ge 3.\n\nA function f  2^S to mathbbR is said to be submodular if\n\nf(X cup Y) + f(X cap Y) le f(X) + f(Y) forall X Y subset S\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.PBO.@quadratization","page":"Booklet","title":"ToQUBO.PBO.@quadratization","text":"@quadratization(name, nsv, nst)\n\nDefines a new quadratization technique.\n\n\n\n\n\n","category":"macro"},{"location":"booklet/#Virtual-Mapping","page":"Booklet","title":"Virtual Mapping","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"During reformulation, ToQUBO holds two distinct models, namely the Source Model and the Target Model. The source model is a generic MOI model restricted to the supported constraints. The target one is on the QUBO form used during the solving process. Both lie within a Virtual Model, which provides the necessary API integration and keeps all variable and constraint mapping tied together.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"This is done in a transparent fashion for both agents since the user will mostly interact with the presented model, and the solvers will only access the generated one.","category":"page"},{"location":"booklet/#Virtual-Variables","page":"Booklet","title":"Virtual Variables","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Every virtual model stores a collection of virtual variables, intended to provide a link between those in the source and those to be created in the target model. Each virtual variable stores enconding information for later expansion and evaluation.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.VirtualMapping.VirtualVariable\nToQUBO.VirtualMapping.mapvar!\nToQUBO.VirtualMapping.expandℝ!\nToQUBO.VirtualMapping.slackℝ!\nToQUBO.VirtualMapping.expandℤ!\nToQUBO.VirtualMapping.slackℤ!\nToQUBO.VirtualMapping.mirror𝔹!\nToQUBO.VirtualMapping.slack𝔹!","category":"page"},{"location":"booklet/#ToQUBO.VirtualMapping.VirtualVariable","page":"Booklet","title":"ToQUBO.VirtualMapping.VirtualVariable","text":"VirtualVariable{S, T}(\n    newvar::Function,\n    source::Union{S, Nothing};\n    bits::Union{Int, Nothing},\n    tech::Symbol,\n    name::Union{Symbol, Nothing}=nothing,\n    α::T=zero(T),\n    β::T=one(T)\n) where {S, T}\n\nThe Virtual Variable Mapping\n\nVariable Expansion techniques:\n\n:𝔹 - Used when a boolean variable is to be mirrored.\n:ℤ₂ - Binary expansion for integer variable.\n:ℤ₁ - Unary expansion for integer variable.\n:ℝ₂ - Binary expansion for real variable.\n:ℝ₁ - Unary expansion for real variable.\n\nReferences:\n\n[1] Chancellor, N. (2019). Domain wall encoding of discrete variables for quantum annealing and QAOA. Quantum Science and Technology, 4(4), 045004. {doi}\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.VirtualMapping.mapvar!","page":"Booklet","title":"ToQUBO.VirtualMapping.mapvar!","text":"mapvar!(model::AbstractVirtualModel{T}, v::VirtualMOIVariable{T}) where {T}\n\nMaps newly created virtual variable v within the virtual model structure. It follows these steps:\n\nMaps v's source to it in the model's source mapping.\nFor every one of v's targets, maps it to itself and adds a binary constraint to it.\nAdds v to the end of the model's varvec.  \n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.VirtualMapping.expandℝ!","page":"Booklet","title":"ToQUBO.VirtualMapping.expandℝ!","text":"expandℝ!(model::QUBOModel{T}, src::VI; bits::Int, name::Symbol, α::T, β::T, semi::Bool) where T\n\nReal Binary Expansion within the closed interval alpha beta.\n\nFor a given variable x in alpha beta we approximate it by\n\nx approx alpha + frac(beta - alpha)2^n - 1 sum_i=0^n-1 2^i y_i\n\nwhere n is the number of bits and y_i in mathbbB.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.VirtualMapping.slackℝ!","page":"Booklet","title":"ToQUBO.VirtualMapping.slackℝ!","text":"slackℝ!(model::AbstractVirtualModel{T}; name::Symbol, α::T, β::T, semi::Bool) where T\n\nAdds real slack variable according to expandℝ!'s expansion method.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.VirtualMapping.expandℤ!","page":"Booklet","title":"ToQUBO.VirtualMapping.expandℤ!","text":"expandℤ!(model::QUBOModel{T}, src::VI; name::Symbol, α::T, β::T, semi::Bool) where T\n\nInteger Binary Expansion within the closed interval leftlceilalpharightrceil leftlfloorbetarightrfloor.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.VirtualMapping.slackℤ!","page":"Booklet","title":"ToQUBO.VirtualMapping.slackℤ!","text":"slackℤ!(model::AbstractVirtualModel{T}; name::Symbol, α::T, β::T) where {T}\n\nAdds integer slack variable according to expandℤ!'s expansion method.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.VirtualMapping.mirror𝔹!","page":"Booklet","title":"ToQUBO.VirtualMapping.mirror𝔹!","text":"mirror𝔹!(model::AbstractVirtualModel{T}, src::Union{VI, Nothing}; name::Symbol) where T\n\nSimply crates a virtual-mapped Doppelgänger into the destination model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#ToQUBO.VirtualMapping.slack𝔹!","page":"Booklet","title":"ToQUBO.VirtualMapping.slack𝔹!","text":"slack𝔹!(model::AbstractVirtualModel{T}; name::Symbol) where {T}\n\nAdds a binary slack variable to the model.\n\n\n\n\n\n","category":"function"},{"location":"booklet/#Virtual-Models","page":"Booklet","title":"Virtual Models","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.VirtualMapping.AbstractVirtualModel\nToQUBO.VirtualQUBOModel","category":"page"},{"location":"booklet/#ToQUBO.VirtualMapping.AbstractVirtualModel","page":"Booklet","title":"ToQUBO.VirtualMapping.AbstractVirtualModel","text":"abstract type AbstractVirtualModel{T} <: MOI.AbstractOptimizer end\n\n\n\n\n\n","category":"type"},{"location":"booklet/#ToQUBO.VirtualQUBOModel","page":"Booklet","title":"ToQUBO.VirtualQUBOModel","text":"VirtualQUBOModel{T}(optimizer::Union{Nothing, Type{<:MOI.AbstractOptimizer}} = nothing) where {T}\n\nThis QUBO Virtual Model links the final QUBO formulation to the original one, allowing variable value retrieving and other features.\n\n\n\n\n\n","category":"type"},{"location":"booklet/#Annealing-and-Sampling","page":"Booklet","title":"Annealing & Sampling","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO's main goal is to benefit from non-deterministic samplers, especially Quantum Adiabatic devices and other Annealing machines. A few MOI-compliant interfaces for annealers and samplers are bundled within ToQUBO via the Anneal.jl submodule and package prototype. Some of them are presented below.","category":"page"},{"location":"booklet/#Quantum-Annealing","page":"Booklet","title":"Quantum Annealing","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Interfacing with D-Wave's quantum computers is one of the milestones we expect to achieve with this package. Like other proprietary optimization resources such as Gurobi and FICO® Xpress, this requires licensing and extra steps are needed to get access to it. In a first moment, for those willing to get started, the Simulated Annealing optimizer might be enough.","category":"page"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"While in JuMP, run using Anneal and look for QuantumAnnealer.Optimizer.","category":"page"},{"location":"booklet/#Simulated-Annealing","page":"Booklet","title":"Simulated Annealing","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Provided by D-Wave's open-source code libraries, this Simulated Annealing engine implements some of the features and configuration you would find using the Quantum API. Its adoption is recommended for basic usage, tests, and during early research steps due to its simplicity and ease of use. It does not implement the most advanced Simulated Annealing algorithm available but performs fairly well on small instances. Anneal.jl exports this interface as SimulatedAnnealer.Optimizer.","category":"page"},{"location":"booklet/#Random-Sampling","page":"Booklet","title":"Random Sampling","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"This sampler is implemented for test purposes and simply assigns 0 or 1 to each variable according to a given probability bias 0 le p le 1, which defaults to p = 05. After running the using Anneal command, RandomSampler.Optimizer will be available.","category":"page"},{"location":"booklet/#Exact-Solver-(Exaustive-Enumeration)","page":"Booklet","title":"Exact Solver (Exaustive Enumeration)","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"Also made to be used in tests, the ExactSolver.Optimizer interface runs through all possible state configurations, which implies in an exponential time complexity on the number of variables. Thus, only problems with no more than 20 variables should be provided.","category":"page"},{"location":"booklet/#MIQP-Solvers","page":"Booklet","title":"MIQP Solvers","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"The most accessible alternative to Annealers and Samplers are Mixed-Integer Quadratic Programming (MIQP) Solvers such as Gurobi and CPLEX. These are not intended to be of regular use alongside ToQUBO since reformulation usually makes things harder for these folks. Yet, there are still cases where they may be suitable for tests on small instances.","category":"page"},{"location":"booklet/#Custom-Error-Types","page":"Booklet","title":"Custom Error Types","text":"","category":"section"},{"location":"booklet/","page":"Booklet","title":"Booklet","text":"ToQUBO.QUBOError","category":"page"},{"location":"booklet/#ToQUBO.QUBOError","page":"Booklet","title":"ToQUBO.QUBOError","text":"QUBOError(msg::Union{Nothing, String})\n\nThis error indicates any failure during QUBO formulation\n\n\n\n\n\n","category":"type"},{"location":"assets/README/#Logo","page":"Logo","title":"Logo","text":"","category":"section"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"The ideia behind ToQUBO's logo comes from a wordplay in Portuguese and Spanish. The package's main purpose is to assemble QUBO Models, which sounds like cubo¹, the translation for cube.","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"(Image: ToQUBO.jl)","category":"page"},{"location":"assets/README/#Colors","page":"Logo","title":"Colors","text":"","category":"section"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"The colors were chosen according to  Julia's Reference for logo graphics². Text color matches the innermost shape and renders fairly well in both light and dark background themes.","category":"page"},{"location":"assets/README/#Typography","page":"Logo","title":"Typography","text":"","category":"section"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"MADETYPE Sunflower³ Font was used. It was converted to a SVG path through the Google Font to Svg Path⁴ online tool.","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"<a href=\"#1\">¹</a> IPA: [ˈkubʊ]","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"<a href=\"#2\">²</a> github.com/JuliaLang/julia-logo-graphics","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"<a href=\"#3\">³</a> Licensed by the authors for use in this project","category":"page"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"<a href=\"#4\">⁴</a> danmarshall.github.io/google-font-to-svg-path","category":"page"},{"location":"assets/README/#Web-Icon-[![ToQUBO.jl](favicon.ico)](/docs/src/assets)","page":"Logo","title":"Web Icon (Image: ToQUBO.jl)","text":"","category":"section"},{"location":"assets/README/","page":"Logo","title":"Logo","text":"The icon used to decorate the documentation resembles an assembled version of the cube with its blue face making up the background.","category":"page"}]
}
